"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
<<<<<<< HEAD
const call_stream_1 = require("./call-stream");
const channel_credentials_1 = require("./channel-credentials");
const resolving_load_balancer_1 = require("./resolving-load-balancer");
const subchannel_pool_1 = require("./subchannel-pool");
const picker_1 = require("./picker");
const constants_1 = require("./constants");
const filter_stack_1 = require("./filter-stack");
const call_credentials_filter_1 = require("./call-credentials-filter");
const deadline_filter_1 = require("./deadline-filter");
const compression_filter_1 = require("./compression-filter");
const resolver_1 = require("./resolver");
const service_config_1 = require("./service-config");
const logging_1 = require("./logging");
const max_message_size_filter_1 = require("./max-message-size-filter");
const http_proxy_1 = require("./http_proxy");
const uri_parser_1 = require("./uri-parser");
=======
const events_1 = require("events");
const http2 = require("http2");
const tls_1 = require("tls");
const url = require("url");
const call_credentials_filter_1 = require("./call-credentials-filter");
const call_stream_1 = require("./call-stream");
const channel_options_1 = require("./channel-options");
const compression_filter_1 = require("./compression-filter");
const constants_1 = require("./constants");
const deadline_filter_1 = require("./deadline-filter");
const filter_stack_1 = require("./filter-stack");
const metadata_status_filter_1 = require("./metadata-status-filter");
const subchannel_1 = require("./subchannel");
const { version: clientVersion } = require('../../package.json');
const MIN_CONNECT_TIMEOUT_MS = 20000;
const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;
const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
var ConnectivityState;
(function (ConnectivityState) {
    ConnectivityState[ConnectivityState["CONNECTING"] = 0] = "CONNECTING";
    ConnectivityState[ConnectivityState["READY"] = 1] = "READY";
    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
    ConnectivityState[ConnectivityState["IDLE"] = 3] = "IDLE";
    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));
<<<<<<< HEAD
let nextCallNumber = 0;
function getNewCallNumber() {
    const callNumber = nextCallNumber;
    nextCallNumber += 1;
    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
        nextCallNumber = 0;
    }
    return callNumber;
}
class ChannelImplementation {
    constructor(target, credentials, options) {
        var _a;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        if (typeof target !== 'string') {
            throw new TypeError('Channel target must be a string');
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
            throw new TypeError('Channel credentials must be a ChannelCredentials object');
        }
        if (options) {
            if (typeof options !== 'object' ||
                !Object.values(options).every((value) => typeof value === 'string' ||
                    typeof value === 'number' ||
                    typeof value === 'undefined')) {
                throw new TypeError('Channel options must be an object with string or number values');
            }
        }
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) {
            throw new Error(`Could not parse target name "${target}"`);
        }
        /* This ensures that the target has a scheme that is registered with the
         * resolver */
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) {
            throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
=======
function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
}
class Http2Channel extends events_1.EventEmitter {
    constructor(address, credentials, options) {
        super();
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = ConnectivityState.IDLE;
        // Helper Promise object only used in the implementation of connect().
        this.connecting = null;
        /* For now, we have up to one subchannel, which will exist as long as we are
         * connecting or trying to connect */
        this.subChannel = null;
        this.subChannelConnectCallback = () => { };
        this.subChannelCloseCallback = () => { };
        this.currentBackoff = INITIAL_BACKOFF_MS;
        for (const option in options) {
            if (options.hasOwnProperty(option)) {
                if (!channel_options_1.recognizedOptions.hasOwnProperty(option)) {
                    console.warn(`Unrecognized channel argument '${option}' will be ignored.`);
                }
            }
        }
        if (credentials._isSecure()) {
            this.target = new url.URL(`https://${address}`);
        }
        else {
            this.target = new url.URL(`http://${address}`);
        }
        // TODO(murgatroid99): Add more centralized handling of channel options
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
        if (this.options['grpc.default_authority']) {
            this.defaultAuthority = this.options['grpc.default_authority'];
        }
        else {
<<<<<<< HEAD
            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
        }
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
         * the grpc.use_local_subchannel_pool channel option means. */
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_a = options['grpc.use_local_subchannel_pool']) !== null && _a !== void 0 ? _a : 0) === 0);
        const channelControlHelper = {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
            },
            updateState: (connectivityState, picker) => {
                this.currentPicker = picker;
                const queueCopy = this.pickQueue.slice();
                this.pickQueue = [];
                for (const { callStream, callMetadata } of queueCopy) {
                    this.tryPick(callStream, callMetadata);
                }
                this.updateState(connectivityState);
            },
            requestReresolution: () => {
                // This should never be called.
                throw new Error('Resolving load balancer should never call requestReresolution');
            },
        };
        // TODO(murgatroid99): check channel arg for default service config
        let defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: [],
        };
        if (options['grpc.service_config']) {
            defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(options['grpc.service_config']));
        }
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, defaultServiceConfig);
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
            new call_credentials_filter_1.CallCredentialsFilterFactory(this),
            new deadline_filter_1.DeadlineFilterFactory(this),
            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
            new compression_filter_1.CompressionFilterFactory(this),
        ]);
    }
    /**
     * Check the picker output for the given call and corresponding metadata,
     * and take any relevant actions. Should not be called while iterating
     * over pickQueue.
     * @param callStream
     * @param callMetadata
     */
    tryPick(callStream, callMetadata) {
        var _a, _b, _c;
        const pickResult = this.currentPicker.pick({ metadata: callMetadata });
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' +
            picker_1.PickResultType[pickResult.pickResultType] +
            ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) +
            ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) +
            ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));
        switch (pickResult.pickResultType) {
            case picker_1.PickResultType.COMPLETE:
                if (pickResult.subchannel === null) {
                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');
                    // End the call with an error
                }
                else {
                    /* If the subchannel is not in the READY state, that indicates a bug
                     * somewhere in the load balancer or picker. So, we log an error and
                     * queue the pick to be tried again later. */
                    if (pickResult.subchannel.getConnectivityState() !==
                        ConnectivityState.READY) {
                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +
                            pickResult.subchannel.getAddress() +
                            ' has state ' +
                            ConnectivityState[pickResult.subchannel.getConnectivityState()]);
                        this.pickQueue.push({ callStream, callMetadata });
                        break;
                    }
                    /* We need to clone the callMetadata here because the transparent
                     * retry code in the promise resolution handler use the same
                     * callMetadata object, so it needs to stay unmodified */
                    callStream.filterStack
                        .sendMetadata(Promise.resolve(callMetadata.clone()))
                        .then((finalMetadata) => {
                        const subchannelState = pickResult.subchannel.getConnectivityState();
                        if (subchannelState === ConnectivityState.READY) {
                            try {
                                pickResult.subchannel.startCallStream(finalMetadata, callStream);
                            }
                            catch (error) {
                                if (error.code ===
                                    'ERR_HTTP2_GOAWAY_SESSION') {
                                    /* An error here indicates that something went wrong with
                                     * the picked subchannel's http2 stream right before we
                                     * tried to start the stream. We are handling a promise
                                     * result here, so this is asynchronous with respect to the
                                     * original tryPick call, so calling it again is not
                                     * recursive. We call tryPick immediately instead of
                                     * queueing this pick again because handling the queue is
                                     * triggered by state changes, and we want to immediately
                                     * check if the state has already changed since the
                                     * previous tryPick call. We do this instead of cancelling
                                     * the stream because the correct behavior may be
                                     * re-queueing instead, based on the logic in the rest of
                                     * tryPick */
                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' +
                                        pickResult.subchannel.getAddress() +
                                        ' with error ' +
                                        error.message +
                                        '. Retrying pick');
                                    this.tryPick(callStream, callMetadata);
                                }
                                else {
                                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' +
                                        pickResult.subchannel.getAddress() +
                                        ' with error ' +
                                        error.message +
                                        '. Ending call');
                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to start HTTP/2 stream');
                                }
                            }
                        }
                        else {
                            /* The logic for doing this here is the same as in the catch
                             * block above */
                            logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' +
                                pickResult.subchannel.getAddress() +
                                ' has state ' +
                                ConnectivityState[subchannelState] +
                                ' after metadata filters. Retrying pick');
                            this.tryPick(callStream, callMetadata);
                        }
                    }, (error) => {
                        // We assume the error code isn't 0 (Status.OK)
                        callStream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
                    });
                }
                break;
            case picker_1.PickResultType.QUEUE:
                this.pickQueue.push({ callStream, callMetadata });
                break;
            case picker_1.PickResultType.TRANSIENT_FAILURE:
                if (callMetadata.getOptions().waitForReady) {
                    this.pickQueue.push({ callStream, callMetadata });
                }
                else {
                    callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
                }
                break;
            default:
                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
        }
    }
    removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
            this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
    }
    updateState(newState) {
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) +
            ' ' +
            ConnectivityState[this.connectivityState] +
            ' -> ' +
            ConnectivityState[newState]);
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
            if (newState !== watcherObject.currentState) {
                clearTimeout(watcherObject.timer);
                this.removeConnectivityStateWatcher(watcherObject);
                watcherObject.callback();
            }
        }
    }
    _startCallStream(stream, metadata) {
        this.tryPick(stream, metadata.clone());
    }
    close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(ConnectivityState.SHUTDOWN);
        this.subchannelPool.unrefUnusedSubchannels();
    }
    getTarget() {
        return uri_parser_1.uriToString(this.target);
    }
    getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
            this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
        const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
        const now = new Date();
        if (deadlineDate <= now) {
            process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
            return;
        }
        const watcherObject = {
            currentState,
            callback,
            timer: setTimeout(() => {
                this.removeConnectivityStateWatcher(watcherObject);
                callback(new Error('Deadline passed without connectivity state change'));
            }, deadlineDate.getTime() - now.getTime()),
        };
        this.connectivityStateWatchers.push(watcherObject);
    }
    createCall(method, deadline, host, parentCall, // eslint-disable-line @typescript-eslint/no-explicit-any
    propagateFlags) {
        if (typeof method !== 'string') {
            throw new TypeError('Channel#createCall: method must be a string');
        }
        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
            throw new TypeError('Channel#createCall: deadline must be a number or Date');
        }
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        const callNumber = getNewCallNumber();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) +
            ' createCall [' +
            callNumber +
            '] method="' +
            method +
            '", deadline=' +
            deadline);
        const finalOptions = {
            deadline: deadline,
            flags: propagateFlags || 0,
            host: host || this.defaultAuthority,
            parentCall: parentCall || null,
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        return stream;
    }
}
exports.ChannelImplementation = ChannelImplementation;
=======
            this.defaultAuthority = this.target.host;
        }
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
            new call_credentials_filter_1.CallCredentialsFilterFactory(this),
            new deadline_filter_1.DeadlineFilterFactory(this),
            new metadata_status_filter_1.MetadataStatusFilterFactory(this),
            new compression_filter_1.CompressionFilterFactory(this),
        ]);
        this.currentBackoffDeadline = new Date();
        /* The only purpose of these lines is to ensure that this.backoffTimerId has
         * a value of type NodeJS.Timer. */
        this.backoffTimerId = setTimeout(() => { }, 0);
        // Build user-agent string.
        this.userAgent = [
            options['grpc.primary_user_agent'],
            `grpc-node-js/${clientVersion}`,
            options['grpc.secondary_user_agent'],
        ]
            .filter(e => e)
            .join(' '); // remove falsey values first
    }
    handleStateChange(oldState, newState) {
        const now = new Date();
        switch (newState) {
            case ConnectivityState.CONNECTING:
                if (oldState === ConnectivityState.IDLE) {
                    this.currentBackoff = INITIAL_BACKOFF_MS;
                    this.currentBackoffDeadline = new Date(now.getTime() + INITIAL_BACKOFF_MS);
                }
                else if (oldState === ConnectivityState.TRANSIENT_FAILURE) {
                    this.currentBackoff = Math.min(this.currentBackoff * BACKOFF_MULTIPLIER, MAX_BACKOFF_MS);
                    const jitterMagnitude = BACKOFF_JITTER * this.currentBackoff;
                    this.currentBackoffDeadline = new Date(now.getTime() +
                        this.currentBackoff +
                        uniformRandom(-jitterMagnitude, jitterMagnitude));
                }
                this.startConnecting();
                break;
            case ConnectivityState.READY:
                this.emit('connect');
                break;
            case ConnectivityState.TRANSIENT_FAILURE:
                this.subChannel = null;
                this.backoffTimerId = setTimeout(() => {
                    this.transitionToState([ConnectivityState.TRANSIENT_FAILURE], ConnectivityState.CONNECTING);
                }, this.currentBackoffDeadline.getTime() - now.getTime());
                break;
            case ConnectivityState.IDLE:
            case ConnectivityState.SHUTDOWN:
                if (this.subChannel) {
                    this.subChannel.close();
                    this.subChannel.removeListener('connect', this.subChannelConnectCallback);
                    this.subChannel.removeListener('close', this.subChannelCloseCallback);
                    this.subChannel = null;
                    this.emit('shutdown');
                    clearTimeout(this.backoffTimerId);
                }
                break;
            default:
                throw new Error('This should never happen');
        }
    }
    // Transition from any of a set of oldStates to a specific newState
    transitionToState(oldStates, newState) {
        if (oldStates.indexOf(this.connectivityState) > -1) {
            const oldState = this.connectivityState;
            this.connectivityState = newState;
            this.handleStateChange(oldState, newState);
            this.emit('connectivityStateChanged', newState);
        }
    }
    startConnecting() {
        const connectionOptions = this.credentials._getConnectionOptions() || {};
        if (connectionOptions.secureContext !== null) {
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (this.options['grpc.ssl_target_name_override']) {
                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];
                connectionOptions.checkServerIdentity = (host, cert) => {
                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
                };
                connectionOptions.servername = sslTargetNameOverride;
            }
        }
        const subChannel = new subchannel_1.Http2SubChannel(this.target, connectionOptions, this.userAgent, this.options);
        this.subChannel = subChannel;
        const now = new Date();
        const connectionTimeout = Math.max(this.currentBackoffDeadline.getTime() - now.getTime(), MIN_CONNECT_TIMEOUT_MS);
        const connectionTimerId = setTimeout(() => {
            // This should trigger the 'close' event, which will send us back to
            // TRANSIENT_FAILURE
            subChannel.close();
        }, connectionTimeout);
        this.subChannelConnectCallback = () => {
            // Connection succeeded
            clearTimeout(connectionTimerId);
            this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY);
        };
        subChannel.once('connect', this.subChannelConnectCallback);
        this.subChannelCloseCallback = () => {
            // Connection failed
            clearTimeout(connectionTimerId);
            /* TODO(murgatroid99): verify that this works for
             * CONNECTING->TRANSITIVE_FAILURE see nodejs/node#16645 */
            this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY], ConnectivityState.TRANSIENT_FAILURE);
        };
        subChannel.once('close', this.subChannelCloseCallback);
    }
    _startHttp2Stream(authority, methodName, stream, metadata) {
        const connectMetadata = this.connect().then(() => metadata.clone());
        const finalMetadata = stream.filterStack.sendMetadata(connectMetadata);
        finalMetadata
            .then(metadataValue => {
            const headers = metadataValue.toHttp2Headers();
            headers[HTTP2_HEADER_AUTHORITY] = authority;
            headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
            headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
            headers[HTTP2_HEADER_METHOD] = 'POST';
            headers[HTTP2_HEADER_PATH] = methodName;
            headers[HTTP2_HEADER_TE] = 'trailers';
            if (this.connectivityState === ConnectivityState.READY) {
                const subChannel = this.subChannel;
                subChannel.startCallStream(metadataValue, stream);
            }
            else {
                /* In this case, we lost the connection while finalizing
                 * metadata. That should be very unusual */
                setImmediate(() => {
                    this._startHttp2Stream(authority, methodName, stream, metadata);
                });
            }
        })
            .catch((error) => {
            // We assume the error code isn't 0 (Status.OK)
            stream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
        });
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        const finalOptions = {
            deadline: deadline === null || deadline === undefined ? Infinity : deadline,
            flags: propagateFlags || 0,
            host: host || this.defaultAuthority,
            parentCall: parentCall || null,
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory);
        return stream;
    }
    /**
     * Attempts to connect, returning a Promise that resolves when the connection
     * is successful, or rejects if the channel is shut down.
     */
    connect() {
        if (this.connectivityState === ConnectivityState.READY) {
            return Promise.resolve();
        }
        else if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            return Promise.reject(new Error('Channel has been shut down'));
        }
        else {
            // In effect, this.connecting is only assigned upon the first attempt to
            // transition from IDLE to CONNECTING, so this condition could have also
            // been (connectivityState === IDLE).
            if (!this.connecting) {
                this.connecting = new Promise((resolve, reject) => {
                    this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);
                    const onConnect = () => {
                        this.connecting = null;
                        this.removeListener('shutdown', onShutdown);
                        resolve();
                    };
                    const onShutdown = () => {
                        this.connecting = null;
                        this.removeListener('connect', onConnect);
                        reject(new Error('Channel has been shut down'));
                    };
                    this.once('connect', onConnect);
                    this.once('shutdown', onShutdown);
                });
            }
            return this.connecting;
        }
    }
    getConnectivityState(tryToConnect) {
        if (tryToConnect) {
            this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);
        }
        return this.connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState !== currentState) {
            /* If the connectivity state is different from the provided currentState,
             * we assume that a state change has successfully occurred */
            setImmediate(callback);
        }
        else {
            let deadlineMs = 0;
            if (deadline instanceof Date) {
                deadlineMs = deadline.getTime();
            }
            else {
                deadlineMs = deadline;
            }
            let timeout = deadlineMs - Date.now();
            if (timeout < 0) {
                timeout = 0;
            }
            const timeoutId = setTimeout(() => {
                this.removeListener('connectivityStateChanged', eventCb);
                callback(new Error('Channel state did not change before deadline'));
            }, timeout);
            const eventCb = () => {
                clearTimeout(timeoutId);
                callback();
            };
            this.once('connectivityStateChanged', eventCb);
        }
    }
    getTarget() {
        return this.target.toString();
    }
    close() {
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        this.transitionToState([
            ConnectivityState.CONNECTING,
            ConnectivityState.READY,
            ConnectivityState.TRANSIENT_FAILURE,
            ConnectivityState.IDLE,
        ], ConnectivityState.SHUTDOWN);
    }
}
exports.Http2Channel = Http2Channel;
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
//# sourceMappingURL=channel.js.map