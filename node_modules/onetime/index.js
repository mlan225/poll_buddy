'use strict';
const mimicFn = require('mimic-fn');

<<<<<<< HEAD
const calledFunctions = new WeakMap();

const oneTime = (fn, options = {}) => {
=======
module.exports = (fn, opts) => {
	// TODO: Remove this in v3
	if (opts === true) {
		throw new TypeError('The second argument is now an options object');
	}

>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
	if (typeof fn !== 'function') {
		throw new TypeError('Expected a function');
	}

<<<<<<< HEAD
	let ret;
	let isCalled = false;
	let callCount = 0;
	const functionName = fn.displayName || fn.name || '<anonymous>';

	const onetime = function (...args) {
		calledFunctions.set(onetime, ++callCount);

		if (isCalled) {
			if (options.throw === true) {
				throw new Error(`Function \`${functionName}\` can only be called once`);
=======
	opts = opts || {};

	let ret;
	let called = false;
	const fnName = fn.displayName || fn.name || '<anonymous>';

	const onetime = function () {
		if (called) {
			if (opts.throw === true) {
				throw new Error(`Function \`${fnName}\` can only be called once`);
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
			}

			return ret;
		}

<<<<<<< HEAD
		isCalled = true;
		ret = fn.apply(this, args);
=======
		called = true;
		ret = fn.apply(this, arguments);
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
		fn = null;

		return ret;
	};

	mimicFn(onetime, fn);
<<<<<<< HEAD
	calledFunctions.set(onetime, callCount);

	return onetime;
};

module.exports = oneTime;
// TODO: Remove this for the next major release
module.exports.default = oneTime;

module.exports.callCount = fn => {
	if (!calledFunctions.has(fn)) {
		throw new Error(`The given function \`${fn.name}\` is not wrapped by the \`onetime\` package`);
	}

	return calledFunctions.get(fn);
};
=======

	return onetime;
};
>>>>>>> 7667619318f2e7e4ad64e58abdc3812448859fd9
